---
title: "Final_Project_OLS_LASSO_Tree"
author: "Wonjae Oh"
date: "University of North Carolina | ECON 370 Final Project"
output:
  tufte::tufte_html: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
library(tufte)
```

## Introduction and structure

This R Markdown file is the main driver for the *R-side* of the project. It

- pulls and cleans data in R with `R/data_preprocessing.R`
- builds expanding-window OLS, LASSO, and decision tree benchmarks
- constructs simple trading rules from each model’s forecasts
- compares out-of-sample performance of the three strategies to buy-and-hold

The Python EZ PPO part is handled separately; this document focuses on OLS/LASSO/tree.

---

## Packages and sources

```{r packages}
library(tidyquant)
library(dplyr)
library(tidyr)
library(lubridate)
library(glmnet)
library(ggplot2)
library(rpart)
library(rpart.plot)

# R helpers for data extraction and cleaning
source("R/data_preprocessing.R")

# Ensure the CSV and Total_data exist and are up to date
Total_data <- build_total_data()

cat("Sample-set counts from R (40/20/40 split):\n")
print(table(Total_data$sample_set))

cat("Sample-set proportions:\n")
print(prop.table(table(Total_data$sample_set)))
```

---

## Variable reasoning

Our target is next month S\&P 500 simple return (`predicting_return`). Predictors combine macro, rates, credit, volatility and momentum, and must reach at least 10 variables from 4 or more data sources. Here we use

- current and lagged monthly S\&P 500 returns (market momentum)
- real GDP growth rate
- personal savings rate
- unemployment rate
- CPI inflation
- effective federal funds rate
- 10 year minus 2 year Treasury term spread
- BAA corporate bond yield
- VIX monthly return

Economic stories:

- macro growth and savings capture aggregate demand and buffer stock behavior  
- unemployment and spreads proxy for business cycle risk  
- inflation and policy rates describe the nominal environment  
- VIX and past returns capture risk appetite and trend following  

All of these are monthly series either from FRED or market data.

---

## Data extraction, cleaning, and combining (R)

All data work lives in `R/data_preprocessing.R`. This Rmd only calls a single function and checks the result.

```{r build-data}
Total_data <- build_total_data()

glimpse(Total_data)
summary(Total_data$predicting_return)

cat("Any NA? ", anyNA(Total_data), "\n")
cat("Number of rows: ", nrow(Total_data), "\n")
range(Total_data$predicting_date)
```

By construction, `Total_data` should have

- `predicting_date` from 1985-01-01 to 2024-12-01  
- 480 rows (40 years times 12 months)  
- columns: `predicting_date`, `predicting_return` and at least 10 predictors  

If any of these checks fail, fix `build_total_data()` before moving on.

---

## Simple exploration

```{r exploration}
# pairwise correlations between future return and predictors
cors <- cor(
  Total_data$predicting_return,
  Total_data %>% dplyr::select(-predicting_date, -predicting_return)
)

cors

# 5 year (60-month) rolling correlations
Rolling_corr <- Total_data %>%
  dplyr::select(predicting_date, -predicting_return)

var_names <- names(Rolling_corr)[names(Rolling_corr) != "predicting_date"]
Rolling_corr[, var_names] <- NA_real_

window_len <- 60

for (i in 1:(nrow(Total_data) - window_len + 1)) {
  idx <- i:(i + window_len - 1)
  Rolling_corr$predicting_date[i + window_len - 1] <- Total_data$predicting_date[i + window_len - 1]
  Rolling_corr[i + window_len - 1, var_names] <- cor(
    Total_data$predicting_return[idx],
    Total_data[idx, var_names]
  )
}

Rolling_corr_long <- Rolling_corr %>%
  tidyr::drop_na() %>%
  tidyr::pivot_longer(
    -predicting_date,
    names_to = "Variable",
    values_to = "rolling_corr"
  )

ggplot(Rolling_corr_long,
       aes(x = predicting_date, y = rolling_corr, color = Variable)) +
  geom_line(linewidth = 0.7) +
  theme_minimal() +
  labs(
    title = "Five-year rolling correlation with future return",
    x = "Date",
    y = "Rolling correlation"
  ) +
  theme(legend.position = "top")
```

---

## Expanding-window OLS, LASSO, and decision tree

We follow the course structure. For calendar year `i` between 2009 and 2024,

- **OLS** training uses all data from 1985 up to year `i - 1`.  
- **LASSO** and **decision tree** use an expanding training/validation split:  
  - training: 1985 up to `i - 9` (inclusive)  
  - validation: `i - 8` to `i - 1`  
- Out-of-sample test is the full year `i`.

```{r oos-models}
# define predictors explicitly (everything except date and target)
pred_vars <- setdiff(names(Total_data), c("predicting_date", "predicting_return"))

lambda_grid <- 10 ^ seq(-3, 3, length.out = 40)
cv_errors_lasso  <- numeric(length(lambda_grid))

# modest grid for decision-tree cp
cp_grid <- c(0.001, 0.005, 0.01, 0.02, 0.05)
cv_errors_tree <- numeric(length(cp_grid))

Testing_result <- Total_data %>%
  dplyr::filter(lubridate::year(predicting_date) >= 2009) %>%
  dplyr::transmute(
    predicting_date,
    actual_return       = predicting_return,
    fitted_return_OLS   = NA_real_,
    fitted_return_LASSO = NA_real_,
    fitted_return_Tree  = NA_real_
  )

for (i_year in 2009:2024) {
  # OLS training on all history before i_year
  train_ols <- Total_data %>%
    dplyr::filter(lubridate::year(predicting_date) < i_year)

  # LASSO / tree training and validation split
  train_start <- 1985
  val_start   <- i_year - 8  # 8-year validation window

  train_lasso <- Total_data %>%
    dplyr::filter(
      lubridate::year(predicting_date) >= train_start,
      lubridate::year(predicting_date) <  val_start
    )

  val_lasso <- Total_data %>%
    dplyr::filter(
      lubridate::year(predicting_date) >= val_start,
      lubridate::year(predicting_date) <  i_year
    )

  test_x <- Total_data %>%
    dplyr::filter(lubridate::year(predicting_date) == i_year) %>%
    dplyr::select(dplyr::all_of(pred_vars))

  # --- LASSO tuning on validation set ---
  x_train <- train_lasso %>% dplyr::select(dplyr::all_of(pred_vars)) %>% as.matrix()
  y_train <- train_lasso$predicting_return

  x_val <- val_lasso %>% dplyr::select(dplyr::all_of(pred_vars)) %>% as.matrix()
  y_val <- val_lasso$predicting_return

  for (j in seq_along(lambda_grid)) {
    m_lasso <- glmnet(x_train, y_train, alpha = 1, lambda = lambda_grid[j])
    y_pred_val <- as.numeric(predict(m_lasso, newx = x_val))
    cv_errors_lasso[j] <- mean((y_val - y_pred_val) ^ 2)
  }

  best_lambda <- lambda_grid[which.min(cv_errors_lasso)]

  x_tv <- rbind(x_train, x_val)
  y_tv <- c(y_train, y_val)

  m_lasso_best <- glmnet(x_tv, y_tv, alpha = 1, lambda = best_lambda)

  x_test_mat <- as.matrix(test_x)
  y_pred_test_lasso <- as.numeric(predict(m_lasso_best, newx = x_test_mat))

  # --- Decision tree tuning on validation set ---
  # Fit separate trees on train_lasso for each cp, pick cp minimizing val MSE
  for (k in seq_along(cp_grid)) {
    tree_k <- rpart(
      predicting_return ~ . - predicting_date,
      data = train_lasso,
      method = "anova",
      control = rpart.control(cp = cp_grid[k], minsplit = 20)
    )
    y_pred_val_tree <- predict(tree_k, newdata = val_lasso)
    cv_errors_tree[k] <- mean((y_val - y_pred_val_tree) ^ 2)
  }

  best_cp <- cp_grid[which.min(cv_errors_tree)]

  # Refit tree on combined train+val with best_cp
  trainval_tree <- dplyr::bind_rows(train_lasso, val_lasso)

  m_tree_best <- rpart(
    predicting_return ~ . - predicting_date,
    data = trainval_tree,
    method = "anova",
    control = rpart.control(cp = best_cp, minsplit = 20)
  )

  y_pred_test_tree <- predict(m_tree_best, newdata = test_x)

  # --- OLS benchmark on all data before i_year ---
  m_ols <- lm(
    predicting_return ~ . - predicting_date,
    data = train_ols
  )

  y_pred_test_ols <- predict(
    m_ols,
    newdata = Total_data %>% dplyr::filter(lubridate::year(predicting_date) == i_year)
  )

  # store in Testing_result
  Testing_result$fitted_return_LASSO[lubridate::year(Testing_result$predicting_date) == i_year] <- y_pred_test_lasso
  Testing_result$fitted_return_OLS[lubridate::year(Testing_result$predicting_date) == i_year]   <- y_pred_test_ols
  Testing_result$fitted_return_Tree[lubridate::year(Testing_result$predicting_date) == i_year]  <- y_pred_test_tree
}

head(Testing_result)
```

Optionally, you can inspect an example fitted tree for a given year using `rpart.plot(m_tree_best)` inside the loop for a specific `i_year`.

---

## Residual plots and out-of-sample R-squared

```{r residuals-r2}
R_Sq_oos <- function(actual, fitted) {
  1 - sum((actual - fitted) ^ 2) / sum(actual ^ 2)
}

r2_ols   <- R_Sq_oos(Testing_result$actual_return, Testing_result$fitted_return_OLS)
r2_lasso <- R_Sq_oos(Testing_result$actual_return, Testing_result$fitted_return_LASSO)
r2_tree  <- R_Sq_oos(Testing_result$actual_return, Testing_result$fitted_return_Tree)

cat("OOS R^2 OLS   :", r2_ols,   "\n")
cat("OOS R^2 LASSO :", r2_lasso, "\n")
cat("OOS R^2 Tree  :", r2_tree,  "\n")

Residual_long <- Testing_result %>%
  tidyr::pivot_longer(
    cols = c(fitted_return_OLS, fitted_return_LASSO, fitted_return_Tree),
    names_to = "Model",
    values_to = "Fitted"
  ) %>%
  dplyr::mutate(
    Model    = dplyr::recode(Model,
                             fitted_return_OLS   = "OLS",
                             fitted_return_LASSO = "LASSO",
                             fitted_return_Tree  = "Tree"),
    Residual = actual_return - Fitted
  )

ggplot(Residual_long,
       aes(x = actual_return, y = Residual, color = Model)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(
    x = "Actual next month return",
    y = "Residual",
    color = "Model",
    title = "Residual vs actual for OLS, LASSO, and decision tree"
  ) +
  theme_minimal() +
  theme(legend.position = "top")
```

---

## Trading strategies from model forecasts

We build very simple trading rules:

- go long the index next month if the model’s forecast is positive  
- sit in cash (0%) if the forecast is negative or zero  

```{r trading-reg}
Trading_Strategy <- Testing_result %>%
  dplyr::mutate(
    Trade_OLS    = (fitted_return_OLS   > 0),
    Trade_LASSO  = (fitted_return_LASSO > 0),
    Trade_Tree   = (fitted_return_Tree  > 0),
    ret_OLS      = Trade_OLS   * actual_return,
    ret_LASSO    = Trade_LASSO * actual_return,
    ret_Tree     = Trade_Tree  * actual_return
  )

Trading_Strategy$CR_OLS      <- NA_real_
Trading_Strategy$CR_LASSO    <- NA_real_
Trading_Strategy$CR_Tree     <- NA_real_
Trading_Strategy$CR_BuyHold  <- NA_real_

Trading_Strategy$CR_OLS[1]      <- 1
Trading_Strategy$CR_LASSO[1]    <- 1
Trading_Strategy$CR_Tree[1]     <- 1
Trading_Strategy$CR_BuyHold[1]  <- 1

for (i in 2:nrow(Trading_Strategy)) {
  Trading_Strategy$CR_OLS[i] <-
    Trading_Strategy$CR_OLS[i - 1] * (1 + Trading_Strategy$ret_OLS[i]   / 100)
  Trading_Strategy$CR_LASSO[i] <-
    Trading_Strategy$CR_LASSO[i - 1] * (1 + Trading_Strategy$ret_LASSO[i] / 100)
  Trading_Strategy$CR_Tree[i] <-
    Trading_Strategy$CR_Tree[i - 1] * (1 + Trading_Strategy$ret_Tree[i]   / 100)
  Trading_Strategy$CR_BuyHold[i] <-
    Trading_Strategy$CR_BuyHold[i - 1] * (1 + Trading_Strategy$actual_return[i] / 100)
}

Trading_long <- Trading_Strategy %>%
  dplyr::select(predicting_date, CR_OLS, CR_LASSO, CR_Tree, CR_BuyHold) %>%
  tidyr::pivot_longer(
    -predicting_date,
    names_to = "Strategy",
    values_to = "CR"
  )

ggplot(Trading_long,
       aes(x = predicting_date, y = CR, color = Strategy)) +
  geom_line(linewidth = 0.8) +
  theme_minimal() +
  labs(
    title = "Cumulative returns: OLS, LASSO, Tree, and Buy & Hold",
    x = "Date",
    y = "Cumulative wealth (start = 1)"
  ) +
  theme(legend.position = "top")
```

---

## Summary statistics table

```{r summary-table}
final_cr <- Trading_Strategy %>%
  summarise(
    CR_OLS     = dplyr::last(CR_OLS),
    CR_LASSO   = dplyr::last(CR_LASSO),
    CR_Tree    = dplyr::last(CR_Tree),
    CR_BuyHold = dplyr::last(CR_BuyHold)
  )

print(final_cr)

avg_monthly <- Trading_Strategy %>%
  summarise(
    avg_ret_OLS     = mean(ret_OLS),
    avg_ret_LASSO   = mean(ret_LASSO),
    avg_ret_Tree    = mean(ret_Tree),
    avg_ret_BuyHold = mean(actual_return)
  )

print(avg_monthly)
```

This completes the R-side comparison of OLS, LASSO, and decision-tree investment decisions on the out-of-sample period 2009–2024.
